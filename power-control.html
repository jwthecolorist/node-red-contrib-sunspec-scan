<!--
  mg-power-control — Editor UI
  Codeless, dropdown/form-driven rule configuration with EditableList
-->
<script type="text/javascript">
(function () {

    // Cache rule type metadata from the server
    var ruleTypesCache = null;

    function getRuleTypes(callback) {
        if (ruleTypesCache) return callback(ruleTypesCache);
        $.getJSON('mg-power-control/rule-types', function (data) {
            ruleTypesCache = data;
            callback(data);
        });
    }

    // Build config fields for a rule type
    function buildConfigFields(container, ruleType, existingConfig) {
        container.empty();
        getRuleTypes(function (types) {
            var typeDef = types[ruleType];
            if (!typeDef || !typeDef.defaults) return;

            var defaults = typeDef.defaults;
            var config = existingConfig || {};

            Object.keys(defaults).forEach(function (key) {
                var defaultVal = defaults[key];
                var currentVal = config[key] !== undefined ? config[key] : defaultVal;

                // Human-readable label
                var label = key
                    .replace(/([A-Z])/g, ' $1')
                    .replace(/^./, function (s) { return s.toUpperCase(); })
                    .replace('Hz', ' (Hz)')
                    .replace('Sec', ' (s)')
                    .replace('Ms', ' (ms)');

                // Unit suffix
                var unit = '';
                if (key.toLowerCase().includes('hz')) unit = ' Hz';
                else if (key.toLowerCase().includes('sec') || key === 'window' || key === 'lockout') unit = ' s';
                else if (key.toLowerCase().includes('threshold') && key.toLowerCase().includes('volt')) unit = ' V';
                else if (key.toLowerCase().includes('threshold') && key.toLowerCase().includes('power')) unit = ' W';
                else if (key.toLowerCase().includes('threshold') && key.toLowerCase().includes('soc')) unit = ' %';
                else if (key.toLowerCase().includes('limit') || key.toLowerCase().includes('swing')) unit = ' VAr';
                else if (key === 'highV' || key === 'lowV') unit = ' V';

                var row = $('<div>', { class: 'form-row', style: 'margin: 4px 0; padding-left: 12px;' });
                row.append($('<label>', {
                    style: 'width: 140px; font-size: 12px; color: #666;',
                    text: label + unit
                }));
                row.append($('<input>', {
                    type: 'number',
                    step: 'any',
                    class: 'rule-config-field',
                    'data-key': key,
                    value: currentVal,
                    style: 'width: 80px;'
                }));
                container.append(row);
            });
        });
    }

    RED.nodes.registerType('mg-power-control', {
        category: 'microgrid',
        color: '#E6735A',
        defaults: {
            name: { value: '' },
            defaultAction: { value: 1, validate: RED.validators.number() },
            heartbeatInterval: { value: 60, validate: RED.validators.number() },
            // Context variable sources
            powerVar: { value: 'power' },
            powerVarType: { value: 'flow' },
            socVar: { value: 'soc' },
            socVarType: { value: 'flow' },
            varVar: { value: 'var' },
            varVarType: { value: 'flow' },
            hzVar: { value: 'hz' },
            hzVarType: { value: 'flow' },
            voltVar: { value: 'voltpha' },
            voltVarType: { value: 'flow' },
            // Rules array
            rules: { value: [] }
        },
        inputs: 1,
        outputs: 1,
        icon: 'font-awesome/fa-shield',
        paletteLabel: 'power control',
        label: function () {
            return this.name || 'power control';
        },
        labelStyle: function () {
            return this.name ? 'node_label_italic' : '';
        },
        oneditprepare: function () {
            var node = this;

            // --- TypedInput for context variables ---
            var inputFields = ['power', 'soc', 'var', 'hz', 'volt'];
            inputFields.forEach(function (key) {
                var varField = '#node-input-' + key + 'Var';
                var typeField = key + 'VarType';
                $(varField).typedInput({
                    default: node[typeField] || 'flow',
                    types: ['msg', 'flow', 'global', 'num'],
                    typeField: '#node-input-' + typeField
                });
            });

            // --- EditableList for Rules ---
            $('#node-input-rules-container').css({ 'min-height': '200px', 'min-width': '450px' }).editableList({
                addButton: 'Add Protection Rule',
                removable: true,
                sortable: true,
                addItem: function (container, i, rule) {
                    // Default new rule
                    if (!rule.type) {
                        rule.type = 'power_soc';
                        rule.enabled = true;
                        rule.config = {};
                    }

                    var row = $('<div>', { style: 'display: flex; align-items: flex-start; flex-direction: column; gap: 6px;' });

                    // --- Top row: Enable toggle + Type dropdown ---
                    var topRow = $('<div>', { style: 'display: flex; align-items: center; gap: 8px; width: 100%;' });

                    // Enable checkbox
                    var enableCb = $('<input>', {
                        type: 'checkbox',
                        checked: rule.enabled !== false,
                        style: 'margin: 0;'
                    });
                    enableCb.on('change', function () {
                        rule.enabled = this.checked;
                        configContainer.toggle(this.checked);
                    });
                    topRow.append(enableCb);

                    // Rule type dropdown
                    var typeSelect = $('<select>', { style: 'width: 200px;' });
                    getRuleTypes(function (types) {
                        Object.keys(types).forEach(function (typeId) {
                            var opt = $('<option>', {
                                value: typeId,
                                text: types[typeId].icon + ' ' + types[typeId].label
                            });
                            if (typeId === rule.type) opt.attr('selected', true);
                            typeSelect.append(opt);
                        });
                    });

                    topRow.append(typeSelect);

                    // Description label
                    var descLabel = $('<span>', {
                        style: 'font-size: 11px; color: #999; margin-left: 8px;',
                        class: 'rule-description'
                    });
                    getRuleTypes(function (types) {
                        if (types[rule.type]) {
                            descLabel.text(types[rule.type].description);
                        }
                    });
                    topRow.append(descLabel);

                    row.append(topRow);

                    // --- Config fields container ---
                    var configContainer = $('<div>', {
                        class: 'rule-config-container',
                        style: 'border-left: 3px solid #E6735A; padding: 4px 0 4px 8px; margin-top: 4px;'
                    });

                    buildConfigFields(configContainer, rule.type, rule.config);
                    if (rule.enabled === false) configContainer.hide();

                    row.append(configContainer);

                    // Type change handler
                    typeSelect.on('change', function () {
                        rule.type = $(this).val();
                        rule.config = {};
                        buildConfigFields(configContainer, rule.type, {});
                        getRuleTypes(function (types) {
                            if (types[rule.type]) {
                                descLabel.text(types[rule.type].description);
                            }
                        });
                    });

                    container.append(row);

                    // Store references for oneditsave
                    container.data('rule', rule);
                    container.data('typeSelect', typeSelect);
                    container.data('enableCb', enableCb);
                    container.data('configContainer', configContainer);
                }
            });

            // Populate existing rules
            if (node.rules) {
                node.rules.forEach(function (rule) {
                    $('#node-input-rules-container').editableList('addItem', JSON.parse(JSON.stringify(rule)));
                });
            }
        },
        oneditsave: function () {
            var node = this;
            var rules = [];

            var items = $('#node-input-rules-container').editableList('items');
            items.each(function () {
                var container = $(this);
                var typeSelect = container.find('select');
                var enableCb = container.find('input[type=checkbox]');
                var configFields = container.find('.rule-config-field');

                var rule = {
                    type: typeSelect.val(),
                    enabled: enableCb.is(':checked'),
                    config: {}
                };

                configFields.each(function () {
                    var key = $(this).data('key');
                    var val = $(this).val();
                    rule.config[key] = parseFloat(val) || 0;
                });

                rules.push(rule);
            });

            node.rules = rules;
        },
        oneditresize: function (size) {
            var rows = $('#dialog-form>div:not(.node-input-rules-container-row)');
            var height = size.height;
            for (var i = 0; i < rows.length; i++) {
                height -= $(rows[i]).outerHeight(true);
            }
            var editorRow = $('#dialog-form>div.node-input-rules-container-row');
            height -= (parseInt(editorRow.css('marginTop')) + parseInt(editorRow.css('marginBottom')));
            height = Math.max(height, 200);
            $('#node-input-rules-container').editableList('height', height);
        }
    });

})();
</script>

<!-- Editor Template -->
<script type="text/html" data-template-name="mg-power-control">

    <!-- General -->
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Power Control">
    </div>

    <div class="form-row">
        <label for="node-input-defaultAction"><i class="fa fa-power-off"></i> Default</label>
        <select id="node-input-defaultAction" style="width: 200px;">
            <option value="1">ON (1) — Normal Operation</option>
            <option value="0">OFF (0) — Default Shutdown</option>
        </select>
    </div>

    <div class="form-row">
        <label for="node-input-heartbeatInterval"><i class="fa fa-heartbeat"></i> Heartbeat</label>
        <input type="number" id="node-input-heartbeatInterval" placeholder="60" style="width: 80px;"> seconds
    </div>

    <!-- Section: Input Sources -->
    <div class="form-row" style="margin-top: 16px;">
        <label style="width: 100%; font-weight: bold; border-bottom: 1px solid #ddd; padding-bottom: 4px;">
            <i class="fa fa-plug"></i> Input Sources
        </label>
    </div>

    <div class="form-row">
        <label for="node-input-powerVar" style="width: 100px;"><i class="fa fa-bolt"></i> Power</label>
        <input type="text" id="node-input-powerVar" style="width: 200px;">
        <input type="hidden" id="node-input-powerVarType">
    </div>

    <div class="form-row">
        <label for="node-input-socVar" style="width: 100px;"><i class="fa fa-battery-half"></i> SOC</label>
        <input type="text" id="node-input-socVar" style="width: 200px;">
        <input type="hidden" id="node-input-socVarType">
    </div>

    <div class="form-row">
        <label for="node-input-varVar" style="width: 100px;"><i class="fa fa-exchange"></i> VAr</label>
        <input type="text" id="node-input-varVar" style="width: 200px;">
        <input type="hidden" id="node-input-varVarType">
    </div>

    <div class="form-row">
        <label for="node-input-hzVar" style="width: 100px;"><i class="fa fa-signal"></i> Hz</label>
        <input type="text" id="node-input-hzVar" style="width: 200px;">
        <input type="hidden" id="node-input-hzVarType">
    </div>

    <div class="form-row">
        <label for="node-input-voltVar" style="width: 100px;"><i class="fa fa-plug"></i> Voltage</label>
        <input type="text" id="node-input-voltVar" style="width: 200px;">
        <input type="hidden" id="node-input-voltVarType">
    </div>

    <!-- Section: Protection Rules -->
    <div class="form-row" style="margin-top: 16px;">
        <label style="width: 100%; font-weight: bold; border-bottom: 1px solid #ddd; padding-bottom: 4px;">
            <i class="fa fa-shield"></i> Protection Rules <span style="font-weight: normal; color: #999; font-size: 11px;">(evaluated top-to-bottom, first trip wins)</span>
        </label>
    </div>

    <div class="form-row node-input-rules-container-row" style="margin-bottom: 0;">
        <ol id="node-input-rules-container"></ol>
    </div>

</script>

<!-- Help Text -->
<script type="text/html" data-help-name="mg-power-control">
    <p>Configurable power control node for microgrid battery/inverter dispatch.</p>

    <h3>Overview</h3>
    <p>Evaluates an ordered set of protection rules against live system readings
    (power, SOC, frequency, voltage, reactive power). The first rule that "trips"
    determines the output action. If no rules trip, the default action is sent.</p>

    <h3>Input Sources</h3>
    <p>Each input can come from <code>flow</code> context, <code>global</code> context,
    <code>msg</code> properties, or a fixed number. Common setup:
    upstream SunSpec/Modbus readers store values in flow context.</p>

    <h3>Rule Types</h3>
    <dl>
        <dt>VAr / Voltage Safety</dt>
        <dd>Trips on reactive power hard limits or oscillation (with optional
        voltage coupling). Configurable lockout duration.</dd>

        <dt>Frequency Support</dt>
        <dd>Forces inverter ON when grid frequency stays above a threshold
        for a sustained duration. Clears when frequency drops below a lower threshold.</dd>

        <dt>Power / SOC Lockout</dt>
        <dd>Shuts down when battery SOC is below threshold AND power
        draw exceeds threshold. Configurable lockout.</dd>

        <dt>Voltage Guard</dt>
        <dd>Trips on over-voltage or under-voltage conditions with lockout.</dd>
    </dl>

    <h3>Output</h3>
    <ul>
        <li><code>msg.payload</code> — Target value (0 = shutdown, 1 = on)</li>
        <li><code>msg.control_status</code> — Human-readable reason string</li>
        <li><code>msg.metrics</code> — Current readings snapshot</li>
        <li><code>msg.topic</code> — "power_control"</li>
    </ul>

    <h3>Throttling</h3>
    <p>Output is only sent when the value changes OR the heartbeat
    interval expires (re-send even if unchanged). This prevents
    flooding downstream Modbus write nodes.</p>

    <h3>Extensibility</h3>
    <p>New rule types can be added by registering a handler function in
    <code>power-control.js</code>'s <code>RULE_HANDLERS</code> map. The editor
    auto-discovers available types via the server API.</p>
</script>
